install.packages("pak")
pak::pak("epiverse-trace/serofoi")
if(!require("remotes")) install.packages("remotes")
remotes::install_github("epiverse-trace/serofoi", ref = "dev")
install.packages("remotes")
remotes::install_github("epiverse-trace/serofoi", ref = "dev")
remotes::install_github("https://epiverse-trace.github.io/serofoi/", ref = "dev")
remotes::install_github("epiverse-trace.github.io/serofoi/", ref = "dev")
remotes::install_github("epiverse-trace.github.io/serofoi/")
pak::pak("epiverse-trace/serofoi@dev")
pak::pak("epiverse-trace/serofoi")
usethis::edit_r_environ()
source("C:/Users/Utente/Desktop/training-2024/session 1.R")
Sys.getenv("GITHUB_PAT")
remotes::install_github("epiverse-trace/serofoi", ref = "dev")
data(chagas2012)
pak::pak("epiverse-trace/serofoi")
data(chagas2012)
if(!require("remotes")) install.packages("remotes")
library(remotes)
library(serofoi)
data("chagas2012")
head(chagas2012)
serodata_test <- prepare_serodata(chagas2012)
plot_seroprev(serodata_test, size_text = 15)
library(cleanepi)
library(tidyverse)
library(incidence2)
bf_pop <- 23.5e6
bf_pop_obj <- epidemics::population(
name = "Burkina Faso",
demography_vector = bf_pop,
contact_matrix = matrix(1.0), # looking  at the pop as a whole without breaking it down into subgroups
initial_conditions = matrix(
c(1-1/bf_pop, 0, 1/bf_pop, 0, 0), # the SEIRV model initial values respectively..
nrow = 1, ncol = 5
)
simple_model <- epidemics::model_default(
population = bf_pop_obj,
recovery_rate = 1/5,
transmission_rate = 9/5, # beta
infectiousness_rate = 1/8, # alpha,
time_end = 120,         # in days
increment = 1           # count the number of people after 1 days
)
view(simple_model) # first scenario, assuming homogeneity !, everyone interacts with everyone else..
simple_model %>%
ggplot(aes(x = time,
y = value, # the number of people moving through various compartments at t
col = compartment)
)+
geom_line()
bf_pop_group <- bf_pop*c(0.44, 0.195, 0.29, 0.05, 0.025)
view(bf_pop_group)
bf_survey <-  socialmixr::get_survey("https://doi.org/10.5281/zenodo.13101862") # we used data from the Gambia instead
bf_contact_data <- socialmixr::contact_matrix(survey = bf_survey,
countries = "Gambia",
age.limits = c(0, 15, 25, 55, 65))
bf_contact_data$participants # to view the details on %, age group and number of participants
bf_contact_data$matrix   # counts of contacts interactions between age groups. On average, an individual
bf_contact_matrix <- t(bf_contact_data$matrix) # we transpose the contact data
bf_contact_matrix
names(bf_pop_group) <- row.names(bf_contact_matrix) # we set the age interval as rownames in the bf_pop_group data table
view(bf_pop_group)
init_conditions <- c(S = 1-1/1e6, E = 0, I = 1/1e6, R = 0, V = 0)
init_conditions_matrix <- rbind(
init_conditions,   # initial conditions for the first group
init_conditions,
init_conditions
)
bf_pop_group_obj <- epidemics::population(
name = "B Faso",
demography_vector = bf_pop_group, # the total population afore defined
initial_conditions = init_conditions_matrix, # appends at each iteration
contact_matrix = bf_contact_matrix # adds the average interactions
)
baseline_model <-  epidemics::model_default(
population = bf_pop_group_obj,
infectiousness_rate = 1/8,
recovery_rate = 1/5,
transmission_rate = 9/5,
time_end = 120,
increment=1
)
view(baseline_model)
# create epidemic curve
baseline_model %>%
ggplot(
aes(x= time, y = value, col= compartment,
linetype = demography_group)
)+
geom_line(linewidth =1.2)+
theme_bw()+
labs(x = "Time (in days)",
y = "cases", title = "Baseline model"
)
vaccine_rollout <- epidemics::vaccination(
name = "vaccine rollout",
time_begin = matrix(c(25, 25, 25, 25, 25), nrow = 5, ncol = 1), # vaccinating all the age groups
time_end = matrix(25 + 50, nrow(bf_contact_matrix)),
nu = matrix(c(0.5, 0.1, 0.1, 0, 0))  # proportion vaccinated per age group.
)
vaccine_model <- epidemics::model_default(
population = bf_pop_group_obj,
time_end = 120,
increment = 1,
recovery_rate = 1/5,
infectiousness_rate = 1/8,
transmission_rate = 9/5,
vaccination = vaccine_rollout
)
view(vaccine_model)
vaccine_model %>%
ggplot(aes(x = time,
y = value,
col = compartment,
linetype = demography_group,
))+
geom_line(linewidth = 1.5)+
labs(x = "Time", y= "Number of cases", title = "Vaccination model")+
theme_bw()
baseline_data <- epidemics::new_infections(
baseline_model, by_group = FALSE  # takes the new infections over time and display
)
view(baseline_data)
baseline_data$scenario <- "baseline"  # add the value baseline to a new column called scenario
# now view the data table again
view(baseline_data)
vaccine_data <- epidemics::new_infections(
vaccine_model, by_group = FALSE
)
vaccine_data$scenario <- "Vaccine"
baseline_vaccine_combined <- rbind(baseline_data, vaccine_data)
view(baseline_vaccine_combined)   # it keeps only the new infections at baseline + vaccine over time
baseline_vaccine_combined %>%
ggplot(aes(
x = time, y = new_infections, col= scenario
))+
geom_line(linewidth = 1)+
labs(x = "Time in days",
y = "Number of new infections", title = "Baseline versus Vaccine")
vaccine_data <- epidemics::new_infections(
vaccine_model, by_group = FALSE,
compartments_from_susceptible = "vaccinated"
)
vaccine_data$scenario <- "Vaccine"
baseline_vaccine_combined <- rbind(baseline_data, vaccine_data)
baseline_vaccine_combined %>%         # this plot now make sense
ggplot(aes(
x = time, y = new_infections, col= scenario
))+
geom_line(linewidth = 1)+
labs(x = "Time in days",
y = "Number of new infections", title = "Baseline versus Vaccine")
mask <- epidemics::intervention(
name = "mask",
time_begin = 30,     # After an outbreak, theres a period when an intervention begins (after 30 days)
time_end = 30 + 60,   # intervention last for 60 days
reduction = 0.3,  # estimate the reduction rate due to intervention from surveys, should be bwn 0 and 1
type = "rate"     # since we want to reduce the rate, type = rate, if we want to reduce the contact, the type = contact
)
mask_model <- epidemics::model_default(
population = bf_pop_group_obj,
recovery_rate = 1/5,
transmission_rate = 9/5,
infectiousness_rate = 1/8,
intervention = list(transmission_rate = mask),
time_end = 120,
increment = 1
)
mask_model %>%
ggplot(aes(x = time, y = value, col= compartment, linetype = demography_group))+
geom_line(linewidth = 1.3)+
labs(x = "Time in days", y = "Number of cases", title = "Number of reduction from NPI")+
theme_bw()
# calculate new infections from mask model
mask_data <- epidemics::new_infections(
mask_model, by_group = FALSE
)
mask_data
# add  a new column to mask data
mask_data$scenario <-  "Mask"
baseline_mask_combinedx <- rbind(
baseline_data, mask_data
)
view(baseline_mask_combinedx)
baseline_mask_combinedx %>%
ggplot(aes(x= time, y = new_infections, col = scenario, linetype = scenario))+
geom_line(linewidth = 1.2)+
labs(x = "Time in days", y = "New infections", title = " Proportion reduction from NPI")+
theme_bw()
library(tidyverse)
epiparameter::epiparameter_db(epi_name = "generation")  # for the generation time
covid_serialint <- epiparameter::epiparameter_db(
disease = "covid",
epi_name = "serial",
# subset = sample_size == 131
single_epiparameter = TRUE  # TO get the dataset with the highest sample size
) #%>%
covid_serialint
covid_serialint$summary_stats$sd
covid_serialint %>% plot()
covid_serialint_params <- covid_serialint %>%
epiparameter::get_parameters()
covid_serialint_params["meanlog"]
EpiNow2::Gamma(
sd = covid_serialint$summary_stats$sd,
mean = covid_serialint$summary_stats$mean,
max = 15
)
covid_serialint_dist <-  EpiNow2::LogNormal(
sd = covid_serialint$summary_stats$sd,
mean = covid_serialint$summary_stats$mean,
max = 15
)
plot(covid_serialint_dist)
covid_reporting <- EpiNow2::Gamma(
mean = EpiNow2::Normal(
mean = 4, sd = 0.5),
sd = EpiNow2::Normal(
mean = 2, sd = 0.5),
max = 20
)
plot(covid_reporting)
#
library(EpiNow2)
library(incidence2)
library(tidyverse)
dplyr::as_tibble(incidence2::covidregionaldataUK)
cases <- incidence2::covidregionaldataUK %>%
as_tibble() %>%
# use {tidyr} to preprocess missing values
tidyr::replace_na(base::list(cases_new = 0)) %>%
# use {incidence2} to compute the daily incidence
incidence2::incidence(
date_index = "date",
counts = "cases_new",
count_values_to = "confirm",
date_names_to = "date",
complete_dates = TRUE
) %>%
dplyr::select(-count_variable) %>%
dplyr::slice_head(n=90) # retain only the last 90 days
cases <- incidence2::covidregionaldataUK %>%
as_tibble() %>%
# use {tidyr} to preprocess missing values
tidyr::replace_na(base::list(cases_new = 0)) %>%
# use {incidence2} to compute the daily incidence
incidence2::incidence(
date_index = "date",
counts = "cases_new",
count_values_to = "confirm",
date_names_to = "date",
complete_dates = TRUE
) %>%
dplyr::select(-count_variable) %>%
dplyr::slice_head(n=90) # retain only the last 90 days
cases
# increase speed
withr::local_options(list(mc.cores= 4))
estimates <- EpiNow2::epinow(
# with slice_head we keep the first 90 rows of the data frame
data = cases %>% dplyr::slice_head(n=90),
generation_time =
EpiNow2::generation_time_opts(covid_serialint_dist),
delays = EpiNow2::delay_opts(covid_reporting + covid_incubation_dist), # NEW object
stan = EpiNow2::stan_opts(
samples = 1000, chains = 3)
)
covid_incubation <- epiparameter::epiparameter_db(
disease = "covid",
epi_name = "incubation",
single_epiparameter = TRUE
)
covid_incubation_params <- epiparameter::get_parameters(
covid_incubation
)
covid_incubation_distr <- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
slog = covid_incubation_params["slog"],
max = 20
)
covid_incubation_distr
covid_incubation <- epiparameter::epiparameter_db(
disease = "covid",
epi_name = "incubation",
single_epiparameter = TRUE
)
"get_citation"
covid_incubation <- epiparameter::epiparameter_db(
disease = "covid",
epi_name = "incubation",
single_epiparameter = TRUE
)
covid_incubation_params <- epiparameter::get_parameters(
covid_incubation
)
covid_incubation_distr <- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
slog = covid_incubation_params["slog"],
max = 20
)
rm(list = ls())
library(EpiNow2)
library(incidence2)
library(tidyverse)
dplyr::as_tibble(incidence2::covidregionaldataUK)
covid_reporting <- EpiNow2::Gamma(
mean = EpiNow2::Normal(
mean = 4, sd = 0.5),
sd = EpiNow2::Normal(
mean = 2, sd = 0.5),
max = 20
)
cases <- incidence2::covidregionaldataUK %>%
as_tibble() %>%
# use {tidyr} to preprocess missing values
tidyr::replace_na(base::list(cases_new = 0)) %>%
# use {incidence2} to compute the daily incidence
incidence2::incidence(
date_index = "date",
counts = "cases_new",
count_values_to = "confirm",
date_names_to = "date",
complete_dates = TRUE
) %>%
dplyr::select(-count_variable) %>%
dplyr::slice_head(n=90) # retain only the last 90 days
cases
# increase speed
withr::local_options(list(mc.cores= 4))
estimates <- EpiNow2::epinow(
# with slice_head we keep the first 90 rows of the data frame
data = cases %>% dplyr::slice_head(n=90),
generation_time =
EpiNow2::generation_time_opts(covid_serialint_dist),
delays = EpiNow2::delay_opts(covid_reporting + covid_incubation_dist), # NEW object
stan = EpiNow2::stan_opts(
samples = 1000, chains = 3)
)
covid_incubation <- epiparameter::epiparameter_db(
disease = "covid",
epi_name = "incubation",
single_epiparameter = TRUE
)
covid_incubation_params <- epiparameter::get_parameters(
covid_incubation
)
covid_incubation_distr <- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
slog = covid_incubation_params["slog"],
max = 20
)
library(tidyverse)
epiparameter::epiparameter_db(epi_name = "generation")  # for the generation time
covid_serialint <- epiparameter::epiparameter_db(
disease = "covid",
epi_name = "serial",
# subset = sample_size == 131
single_epiparameter = TRUE  # TO get the dataset with the highest sample size
) #%>%
covid_serialint
covid_serialint$summary_stats$sd
covid_serialint %>% plot()
covid_serialint_params <- covid_serialint %>%
epiparameter::get_parameters()
covid_serialint_params["meanlog"]
EpiNow2::Gamma(
sd = covid_serialint$summary_stats$sd,
mean = covid_serialint$summary_stats$mean,
max = 15
)
covid_serialint_dist <-  EpiNow2::LogNormal(
sd = covid_serialint$summary_stats$sd,
mean = covid_serialint$summary_stats$mean,
max = 15
)
plot(covid_serialint_dist)
covid_reporting <- EpiNow2::Gamma(
mean = EpiNow2::Normal(
mean = 4, sd = 0.5),
sd = EpiNow2::Normal(
mean = 2, sd = 0.5),
max = 20
)
plot(covid_reporting)
#
library(EpiNow2)
library(incidence2)
library(tidyverse)
dplyr::as_tibble(incidence2::covidregionaldataUK)
cases <- incidence2::covidregionaldataUK %>%
as_tibble() %>%
# use {tidyr} to preprocess missing values
tidyr::replace_na(base::list(cases_new = 0)) %>%
# use {incidence2} to compute the daily incidence
incidence2::incidence(
date_index = "date",
counts = "cases_new",
count_values_to = "confirm",
date_names_to = "date",
complete_dates = TRUE
) %>%
dplyr::select(-count_variable) %>%
dplyr::slice_head(n=90) # retain only the last 90 days
cases
# increase speed
withr::local_options(list(mc.cores= 4))
estimates <- EpiNow2::epinow(
# with slice_head we keep the first 90 rows of the data frame
data = cases %>% dplyr::slice_head(n=90),
generation_time =
EpiNow2::generation_time_opts(covid_serialint_dist),
delays = EpiNow2::delay_opts(covid_reporting + covid_incubation_dist), # NEW object
stan = EpiNow2::stan_opts(
samples = 1000, chains = 3)
)
covid_incubation <- epiparameter::epiparameter_db(
disease = "covid",
epi_name = "incubation",
single_epiparameter = TRUE
)
covid_incubation_params <- epiparameter::get_parameters(
covid_incubation
)
covid_incubation_distr <- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
slog = covid_incubation_params["slog"],
max = 20
)
covid_incubation_distr
# from above
reportx_delay_covid <- EpiNow2::epinow(
# with slice_head we keep the first 90 rows of the data frame
generation_time = EpiNow2::generation_time_opts(covid_serialint_dist),
delays = EpiNow2::delay_opts(covid_reporting + covid_incubation_distr),
stan = EpiNow2::stan_opts(samples = 1000, chains = 3)
)
# To calculate the Rt we need incidence data, generation time, serial interval, incubation time, reporting delays
#
# To calculate the Rt we need incidence data, generation time, serial interval, incubation time, reporting delays
#
# To calculate the Rt we need incidence data, generation time, serial interval, incubation time, reporting delays
#
# To calculate the Rt we need incidence data, generation time, serial interval, incubation time, reporting delays
#
reportx_delay_covid
covid_incubation_distr<- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
slog = covid_incubation_params["slog"],
max = 20
)
covid_incubation_distr<- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
slog = covid_incubation_params["slog"],
max = 20
)
covid_incubation_params <- epiparameter::get_parameters(
covid_incubation
)
covid_incubation_distr<- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
slog = covid_incubation_params["slog"],
max = 20
)
?new_dist_spec
covid_incubation_params <- epiparameter::get_parameters(
covid_incubation
)
epiparameter::get_parameters(
covid_incubation
)
covid_incubation_params<- epiparameter::get_parameters(
covid_incubation
)
covid_serialint_params
covid_incubation_distr<- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
slog = covid_incubation_params["slog"],
max = 20
)
covid_incubation_distr<- EpiNow2::LogNormal(
meanlog = covid_incubation_params["meanlog"],
sdlog = covid_incubation_params["sdlog"],
max = 20
)
# from above
reportx_delay_covid <- EpiNow2::epinow(
# with slice_head we keep the first 90 rows of the data frame
generation_time = EpiNow2::generation_time_opts(covid_serialint_dist),
delays = EpiNow2::delay_opts(covid_reporting + covid_incubation_distr),
stan = EpiNow2::stan_opts(samples = 1000, chains = 3)
)
estimates <- EpiNow2::epinow(
# with slice_head we keep the first 90 rows of the data frame
data = cases %>% dplyr::slice_head(n=90),
generation_time =
EpiNow2::generation_time_opts(covid_serialint_dist),
delays = EpiNow2::delay_opts(covid_reporting + covid_incubation_distr), # NEW object
stan = EpiNow2::stan_opts(
samples = 1000, chains = 3)
)
estimates <- EpiNow2::epinow(
# with slice_head we keep the first 90 rows of the data frame
data = cases %>% dplyr::slice_head(n=90),
generation_time =
EpiNow2::generation_time_opts(covid_serialint_dist),
delays = EpiNow2::delay_opts(covid_reporting + covid_incubation_distr), # NEW object
stan = EpiNow2::stan_opts(
samples = 1000, chains = 3)
)
source("C:/Users/Utente/Desktop/training-2024/s3.R")
